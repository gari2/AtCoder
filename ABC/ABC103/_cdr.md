# [ABC103](https://beta.atcoder.jp/contests/abc103)  
  
## A問題  
小さい順に並べて(A<sub>2</sub> - A<sub>1</sub>) + (A<sub>3</sub> - A<sub>2</sub>)  
解説見たら最大値 - 最小値だった  
  
## B問題  
Sを2つならべてその文字列の中にTが入ってるかどうか  
  
## C問題  
fの最大値は(aの全ての積 - 1)をそれぞれaで割ったものの総和  
(a全ての積 - 1) mod a<sub>1</sub> + (a全ての積 - 1) mod a<sub>2</sub> + ... + (a全ての積 - 1) mod a<sub>n</sub>  
→ i項(0 <= i < n)の最大値はa<sub>i</sub> - 1となる  
→ 総和とる  
[Python3での提出コード](https://beta.atcoder.jp/contests/abc103/submissions/3085172)  
  
## D問題  
とても謎だったが理解できた  
入力例2の場合を考えます  
  
入力例2  
```
9 5
1 8
2 7
3 5
4 6
7 9
```
  
- 下処理  
まず2行目以降（1-started）の入力をペアとして配列に入れる  
一つ目の要素に右の入力、二つ目の要素に左の入力を設定する(逆にする)  
そしてソートする  
ペアのソートは一つ目の要素でソートされる  
そしてそれぞれのペアに対して、一つ目の要素と二つ目の要素をswapする(好み)  
すると、配列はこうなる  
  
```
3 5
4 6
2 7
1 8
7 9
```
  
- 考えたこと  
図を描きます  
![q-ggkd50](https://user-images.githubusercontent.com/37968814/49077424-99817780-f27e-11e8-9762-c529d5068eae.jpg)  
上から順に追っていきます  
現在架けてる一番右の橋につながっている左の島を変数rightにいれます(初期値-1)  
    - 3 5  
    現在，橋は架けていません  
    橋を架ける必要があるのですが、ここで下処理を思い出します  
    配列に入っているのは二つ目の要素が昇順になっているペアです  
    今見ている二つ目の要素がこれから先見ていくペアの中で最小の値です  
    まだ見ぬ範囲の中で同じ橋で事が足りるケースが想定されます  
    同じ橋でなるべく済ませたいということが問題のコンセプトなのでそれを実行していきます  
    4と5の間に橋を架けます  
    - 4 6  
    現在，橋が架かっているのは4と5の間です  
    4と6の行き来を防ぎたいのですが、4と5の間で橋が架かっているので架ける必要はありません  
    これは`(right < x.first)`の条件式が偽になるためです  
    - 2 7  
    現在，橋が架かっているのは4と5の間です  
    2と7の行き来を防ぎたいのですが、4と5の間で橋が架かっているので架ける必要はありません  
    これは`(right < x.first)`の条件式が偽になるためです  
    - 1 8  
    現在，橋が架かっているのは4と5の間です  
    1と8の行き来を防ぎたいのですが、4と5の間で橋が架かっているので架ける必要はありません  
    これは`(right < x.first)`の条件式が偽になるためです  
    - 7 9  
    現在，橋が架かっているのは4と5の間です  
    7と9の行き来を防ぎたいのですが、4と5の間で橋が架かってますが，争いを起こしている島のうち、左側の7は4より大きい（「'より'大きい」が重要．7ではなく4ならば4と5の橋で事足りるので新たに橋を架ける必要がないため）ので新たに橋を架ける  
    橋を架けるのは8と9の間．
    これは`(right < x.first)`の条件式が真になるためです  