# [ABC075](https://beta.atcoder.jp/contests/abc075/)  
  
## A問題  
mapを使用
数値ごとにカウントして1のものを出力  
  
## B問題  
グリッド問題の入門編という印象  
わざわざ答え用の配列を作らなくて良いと後悔  
  
(-1, -1)|(-1, 0)|(-1, 1)  
---|---|---  
**(0, -1)**|**@**|**(0, 1)**  
**(1, -1)**|**(1, 0)**|**(1, 1)**  
  
@: 今いるところ  
(a, b): @よりどれくらい離れているか (aは縦の遷移数、bは横の遷移数、下と右を正とする)  
数学だと(x座標, y座標)と書くことが多いが、私は(height, width)としている  
上の図で示しているのは周りのマスがすべて存在しているときの話であるが、  
もし今いるところが盤面の隅だった場合、すべての遷移ができないので条件分岐が必要である  
→[b.cpp](https://github.com/ozikot/AtCoder/blob/master/ABC075/b.cpp) 27~30行目 (下のコード部分)  
  
```cpp
    bool f1, f2;  
    f1 = (i + dx[k] < 0) or (j + dy[k] < 0);  
    f2 = (i + dx[k] >= h) or (j + dy[k] >= w);  
    if(f1 or f2) continue;  
```  
  
遷移先が盤面内にとどまることを注意する  
  
## C問題  
様々な手法で解くことができる  
一番好きなワーシャルフロイド法で解いた  
[こちらのサイト](http://todai-neet.hateblo.jp/entry/2015/09/11/183740)がとても分かりやすく説明されていると思います  
  
辺の数だけワーシャルフロイドを発動させる  
発動する前に辺を一つ取り除く  
もし、ある辺を取り除いてもすべての島に、島の数以下のコストでたどり着ければ取り除いた辺は橋ではない  
→取り除いた辺以外ですべての島へ行けるということ  
逆に初期化で入れた1e9が入っていればそこにはたどり着けない  
橋をカウントして出力  
