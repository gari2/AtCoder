# [CODE THANKS FESTIVAL 2018(Parallel)](https://beta.atcoder.jp/contests/code-thanks-festival-2018-open)  
[私のすべての提出](https://beta.atcoder.jp/contests/code-thanks-festival-2018-open/submissions?f.Task=&f.Language=&f.Status=&f.User=tokizo)  
  
## A問題  
- A+CがT以下ならB+D  
- AがT以下ならB(*)  
- CがT以下ならD((*)とどっちも満たす場合大きい方)  
- 上記がだめなら0  
の4パターン  
  
## B問題  
コンテスト中に解けなかった  
一回の操作で赤い玉と青い玉は合計で4つ取り出す  
ここで`(X + Y)`が4で割り切れなかったらNo  
  
---  
  
操作は`(X + Y) / 4`(kとする)回行われる  
k回は必ず赤い玉、青い玉ともに1取り出される  
  
```
X -= k  
Y -= k  
```
  
ここでXとYが0以上且つ，偶数ならYesとなる  
例えばX = 7, Y = 5のとき  
X + Y = 12(4で割り切れる)  
k = 12 / 4 = 3  
X -= k  
Y -= k  
X = 4, Y = 2となる  
XとYが0以上且つ、偶数なのでYesとなる  
(4, 2) -> (2, 2) -> (2, 0) -> (0, 0)  
  
## C問題  
解けなかった  
累積和を使うんじゃないかと思ったけどもっとスマートな解き方がありました  
[@satanic0258](https://twitter.com/satanic0258)さんの解説がとても理解しやすく感動したのでそちらで解きました  
  
![obw2-gcs](https://user-images.githubusercontent.com/37968814/48992761-f85ec800-f17c-11e8-91cf-85f42a038309.jpg)  
  
配列はソート済みとする  
図のライン上の地点どうしの差の絶対値の総和が答え  
- i = 1  
地点0と地点1の差  
  
- i = 2  
地点0と地点2の差  
地点1と地点2の差  
  
…とその都度計算していたら計算量が大きくなる  
図を見ると以下のことがわかる  
- (X[i] - X[i - 1])(i >= 1)はi回出現しているのでまとめられる  
- X[i - 1]までの総和 + (X[i] - X[i - 1]) * i とすることでO(n)で処理することができる  
これを実装  
  
## D問題  
私の国語力が無く，読解に時間が掛かった  
問題文より，  
  
>これは code のように、先頭の文字がその文字列においてアルファベット順で最小となる文  
字列を1つ以上連結してできたものです。  
元となるそれぞれの文字列には、先頭と同じ文字が複数含まれていたことはありません  

ということはつまり，
一番最初の文字から見ていき，最初の文字よりアルファベット順で小さい文字が出てきたらその手前で区切る（そこが新たなスタートとなる）  
例えば，'atcoderdaisukida'だと3になる  
これは一番最初の文字が'a'の為，'a'以外`の文字が先頭になることはあり得ない  
例えば，'gfedcba'だと7になる  